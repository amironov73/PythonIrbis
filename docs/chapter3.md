### Классы Record, Field и SubField

Классы `Record`, `Field` и `SubField` предназначены для создания и манипуляции записями, полями и подполями соответственно в клиентском представлении. Они также отвечают за перекодирование записей из серверного представления в клиентское и обратно.

#### Record

Каждый экземпляр класса `Record` соответствует одной записи в базе данных ИРБИС. Он содержит следующие поля:

Поле     | Тип  | Назначение
---------|------|-----------
database | str  | Имя базы данных, из которой загружена данная запись. Для вновь созданных записей `None`
mfn      | int  | Номер записи в мастер-файле. Для вновь созданных записей 0
status   | int  | Статус записи: логически удалена, отсутствует (см. ниже)
version  | int  | Номер версии записи
fields   | list | Список полей записи

Статус записи: набор флагов

Имя                      | Число | Значение
-------------------------|-------|---------
LOGICALLY_DELETED        | 1     | Логически удалена (может быть восстановлена)
PHYSICALLY_DELETED       | 2     | Физически удалена (не может быть восстановлена)
ABSENT                   | 4     | Отсутствует
NON_ACTUALIZED           | 8     | Не актуализирована
LAST                     | 32    | Последняя версия записи
LOCKED                   | 64    | Запись заблокирована на ввод
AUTOIN_ERROR             | 128   | Ошибка в Autoin.gbl.
FULL_TEXT_NOT_ACTUALIZED | 256   | Полный текст не актуализирован. 

* **def \_\_init\_\_(self, \*fields)** -- конструктор, создаёт новый экземпляр записи в памяти клиента. Можно указать поля, которыми будет наполнена запись.

* **def add(self, tag, value = None, \*subfields) -> Record** -- добавляет поле (возможно, со значением и подполями) к записи. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def add_non_empty(self, tag, value) -> Record** -- добавляет поле, если его значение не пустое. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def all(self, tag) -> List\[Field\]** -- возвращает список всех полей с указанной меткой.

* **def clear(self) -> Record** -- очистка записи (удаление всех полей).

* **def clone(self) -> Record** -- создание клона, т. е. полной копии записи. Поля, если присутствуют, тоже клонируются. Возвращает клон записи.

* **def encode(self) -> List\[str\]** -- кодирование записи в серверное представление. Инфраструктурный метод, парный к `parse`.

* **def fm(self, tag, code = '') -> str** -- возвращает значение первого поля с указанной меткой (или значение подполя с указанным кодом).

* **def fma(self, tag, code = '') -> List\[str\]** -- возвращает список значений полей с указанной меткой (или значения подполей с указанным кодом). Пустые значения в список не включаются.

* **def first(self, tag) -> Optional\[Field\]** -- возвращает первое поле с указанной меткой либо `None`.

* **def have_field(self, tag) -> bool** -- выясняет, есть ли в записи поле с указанной меткой.

* **def insert_at(self, index, tag, value = None) -> Field** -- вставка поля в указанной позиции. Возвращает вставленное поле.

* **def is_deleted(self) -> bool** -- удалена ли запись?

* **def parse(self, text)** -- разбор текстового представления записи (в серверном формате). Инфраструктурный метод, парный к `encode`.

* **def remove_at(self, index) -> Record** -- удаляет поле в указанной позиции. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def remove_field(self, tag) -> Record** -- удаляет поля с указанной меткой. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def reset(self) -> Record** -- сбрасывает состояние записи, отвязывая её от базы данных. Поля при этом остаются нетронутыми. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def set_field(self, tag, value) -> Record** -- устанавливает значение первого повторения указанного поля. Если указанное значение пустое, поле удаляется из записи. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def set_subfield(self, tag, code, value) -> Record** -- устанавливает значение подполя в первом повторении указанного поля. Если указанное значение пустое, подполе удаляется из поля. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def \_\_iter\_\_(self)** -- возможность итерироваться по полям.

* **def \_\_iadd\_\_(self, other)** -- возможность использовать оператор `+=` для добавления полей.

* **def \_\_isub\_\_(self, other)** -- возможность использовать оператор `-=` для удаления полей.

* **def \_\_getitem\_\_(self, item)** -- возможность получения значения полей с помощью обращения по индексу. 

* **def \_\_setitem\_\_(self, key, value)** -- возможность присваивания значений полей с помощью обращения по индексу.

* **def \_\_len\_\_(self)** -- количество полей в записи.

* **def \_\_bool\_\_(self)** -- проверка, не пустая ли запись.

* **def \_\_str\_\_(self)** -- получение текстового представления записи.

```python
import irbis

SF = irbis.SubField

record = irbis.Record()
record.add(700, SF('a', 'Миронов')) \
    .add('b', 'А. В.') \
    .add('g', 'Алексей Владимирович')
record.add(200, SF('a', 'Заглавие книги')) \
    .add('e', 'Подзаголовочные сведения')
print(f"Заглавие: {record.fm(200, 'a')}")
print(record)
```

#### Field

Поле      | Тип  | Назначение
----------|------|-----------
tag       | int  | Тег поля
value     | str  | Значение поля до первого разделителя
subfields | list | Список подполей

* **def \_\_init\_\_(self, tag = 0, value = None, \*subfields)** -- конструктор, создаёт новый экземпляр поля в памяти клиента. Можно указать подполя, которыми будет наполнено поле.

* **def add(self, code, value = '') -> Field** -- добавление подполя с указанным кодом (и, возможно, значением) к записи. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def add_non_empty(self, code, value) -> Field** -- добавление подполя с указанным кодом при условии, что значение поля не пустое. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def all(self, code) -> List\[SubField\]** -- возвращает список всех подполей с указанным кодом.

* **def all_values(self, code) -> List\[str\]** -- возвращает список значений всех подполей с указанным кодом. Пустые значения подполей в список не включаются.

* **def assign_from(self, other)** -- присваивание от другого поля. Значение данного поля становится равным значению другого поля. В данное поле помещаются клоны подполей из другого поля. Метка поля не меняется.

* **def clear(self) -> Field** -- очистка поля. Удаляются все подполя и значение до первого разделителя. Возвращает `self`, что позволяет использовать метод в цепочечных вызовах.

* **def clone(self) -> Field** -- создание клона, т. е. полной копии поля. Подполя, если присутствуют, тоже клонируются. Возвращает клон поля.

* **def first(self, code) -> Optional\[SubField\]** -- находит первое подполе с указанным кодом, возвращает найденное подполе или `None`.

* **def first_value(self, code) -> Optional\[str\]** -- находит первое подполе с указанным кодом, возвращает значение найденного подполя или `None`.

* **def get_embedded_fields(self) -> List\[Field\]** -- получение списка встроенных полей.

* **def get_value_or_firs_subfield(self) -> Optional\[str\]** -- выдаёт значение для ^\*.

* **def have_subfield(self, code) -> bool** -- выясняет, есть ли подполе с указанным кодом.

* **def insert_at(self, index: int, code value) -> Field** -- вставляет подполе в указанную позицию. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def parse(self, line)** -- разбор текстового представления поля (в серверном формате). Инфраструктурный метод.

* **def remove_at(self, index) -> Field** -- удаляет подполе в указанной позиции. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def remove_subfield(self, code) -> Field** -- удаляет все подполя с указанным кодом. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def replace_subfield(self, code, old_value, new_value) -> Field** -- заменяет значение подполя с указанным кодом. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def set_subfield(self, code, value) -> Field** -- устанавливает значение первого повторения подполя с указанным кодом. Если `value==None`, подполе удаляется. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def \_\_iter\_\_(self)** -- возможность итерироваться по подполям.

* **def \_\_iadd\_\_(self, other)** -- возможность использовать оператор `+=` для добавления подполей.

* **def \_\_isub\_\_(self, other)** -- возможность использовать оператор `-=` для удаления подполей.

* **def \_\_getitem\_\_(self, item)** -- возможность получения значения подполей с помощью обращения по индексу. 

* **def \_\_setitem\_\_(self, key, value)** -- возможность присваивания значений подполей с помощью обращения по индексу.

* **def \_\_len\_\_(self)** -- количество подполей в поле.

* **def \_\_bool\_\_(self)** -- проверка, не пустое ли поле.

* **def \_\_str\_\_(self)** -- получение текстового представления поля.

```python
import irbis

field = irbis.Field(700)
field.add('a', 'Миронов').add('e', 'А. В.')
field.add('g', 'Алексей Владимирович')
print(field)
```

#### SubField

Поле  | Тип | Назначение
------|-----|-----------
code  | str | Код подполя (односимвольный!)
value | str | Значение подполя

* **def \_\_init\_\_(self, code = '\\0', value = None)** -- конструктор, создаёт новый экземпляр подполя в памяти клиента.

* **def assign_from(self, other)** -- присваивание от другого поля: код и значение берутся от другого подполя.

* **def clone(self) -> SubField** -- клонирование, т. е. создание точной копии подполя. Возвращает клон подполя.

* **def \_\_bool\_\_(self)** -- проверка, не пустое ли подполе.

* **def \_\_str\_\_(self)** -- получение текстового представления подполя.

```python
import irbis

subfield = irbis.SubField('a', 'Подполе A')
print(subfield)
```

#### Класс RawRecord

Запись с нераскодированными полями/подполями. Класс определён в `irbis.ext` и содержит следующие поля:

Поле     | Тип  | Назначение
---------|------|-----------
database | str  | Имя базы данных, из которой загружена данная запись. Для вновь созданных записей `None`
mfn      | int  | Номер записи в мастер-файле. Для вновь созданных записей 0
status   | int  | Статус записи: логически удалена, отсутствует (аналогично `Record`)
version  | int  | Номер версии записи
fields   | list | Список полей записи в нераскодированном виде (просто строки).

Определены следующие методы:

* **def \_\_init\_\_(self, \*fields)** -- конструктор, создаёт новый экземпляр записи в памяти клиента. Можно указать поля, которыми будет наполнена запись.

* **def clear(self) -> RawRecord** -- очистка записи (удаление всех полей).

* **def clone(self) -> RawRecord** -- создание клона, т. е. полной копии записи. Поля, если присутствуют, тоже клонируются. Возвращает клон записи.

* **def encode(self) -> List\[str\]** -- кодирование записи в серверное представление. Инфраструктурный метод, парный к `parse`.

* **def is_deleted(self) -> bool** -- удалена ли запись?

* **def parse(self, text)** -- разбор текстового представления записи (в серверном формате). Инфраструктурный метод, парный к `encode`.

* **def remove_at(self, index) -> Record** -- удаляет поле в указанной позиции. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def reset(self) -> Record** -- сбрасывает состояние записи, отвязывая её от базы данных. Поля при этом остаются нетронутыми. Возвращает `self`, поэтому метод может использоваться в цепочечных вызовах.

* **def \_\_iter\_\_(self)** -- возможность итерироваться по полям.

* **def \_\_len\_\_(self)** -- количество полей в записи.

* **def \_\_bool\_\_(self)** -- проверка, не пустая ли запись.

* **def \_\_str\_\_(self)** -- получение текстового представления записи.

Загрузить сырую запись с сервера можно с помощью метода `read_raw_record`, сохранить на сервере можно с помощью метода `write_raw_record`.

```python
import irbis

client = irbis.Connection()
client.connect('host', 6666, 'librarian', 'secret')
record = client.read_raw_record(123)
record.fields.append('300#Комментарий к записи')
client.write_raw_record(record)
client.disconnect()
```

[Предыдущая глава](chapter2.md) | [Следующая глава](chapter4.md)